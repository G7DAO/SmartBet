{
  "language": "Solidity",
  "sources": {
    "contracts/facets/SmartBetFacet.sol": {
      "content": "pragma solidity ^0.8.17;\n\nimport {LibSmartBet} from \"../libraries/LibSmartBet.sol\";\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {IMockERC1155} from \"../interfaces/IMockERC1155.sol\";\nimport {IGameEngine} from \"../interfaces/IGameEngine.sol\";\n\n/**\n * @title SmartFacet Smart Contract\n * @author Carlos Ramos\n * @notice Development in progress - can contribute to the repo https://github.com/jrcarlos2000/eth-denver-contracts\n * @dev contract needs to check weather the caller is a member of the DAO - need to add terminus \n */\n\ncontract SmartBetFacet {\n\n    uint256 constant MIN_TIME = 3 days; // minimun duration of a game\n\n    /**\n     * @notice Emitted when Game is opened by the owner\n     * @param gameId - the index of the new game\n     * @param  gameData - data of the new game created\n     */\n    event GameOpened(uint256 gameId, LibSmartBet.Game gameData);\n\n    /**\n     * @notice Emitted when a new session is created\n     * @param sessionId - the index of the new session\n     * @param sessionData - data of the session, data contains weather a session can be started\n     * @param player - the one who opened the session\n     */\n    event SessionOpened(uint256 sessionId, LibSmartBet.Session sessionData, address player);\n\n    /**\n     * @notice Emitted when a user joins a session\n     * @param sessionId - the index of the session\n     * @param sessionData - data of the session\n     * @param player - the one who joins the session\n     */\n    event SessionJoined(uint256 sessionId, LibSmartBet.Session sessionData, address player);\n\n    /**\n     * @notice Emitted when a move is submitted\n     * @param sessionId - the index of the session\n     * @param moveData - data of the session\n     * @param player - the one who submits the move\n     * @param isFinalMove - weather will require you to submit combination\n     */\n    event MoveSubmitted(uint256 sessionId, LibSmartBet.Move moveData, address player, bool isFinalMove);\n\n    /**\n     * @notice Emitted when combination is submitted\n     * @param sessionId - index of the session\n     * @param player - the one owner of the combination\n     * @param combination - the combination submitted\n     */\n    event CombinationSumitted(uint256 sessionId, address player, bytes combination);\n\n    /**\n     * @notice Emitted when session finishes\n     * @param sessionId - index of the session\n     * @param winner - the winner of the game\n     */\n    event SessionEnded(uint256 sessionId, address winner);\n\n    function _onlyOwner() internal view {\n        require(LibDiamond.contractOwner() == msg.sender, \"SmartBetFacet : Function can only be called by owner\");\n    }\n\n    modifier isActiveSession(uint256 sessionId) {\n        require(LibSmartBet.smartBetStorage().sessionBook[sessionId].isActive,\"SmartBetFacet : Session not active\");\n        _;\n    }\n\n    modifier canMakeMove(uint256 sessionId) {\n        LibSmartBet.Session memory session = LibSmartBet.smartBetStorage().sessionBook[sessionId];\n        require(session.players[session.turnOf] == msg.sender, \"not turn of the sender\");\n        require(session.canPlay, \"session hasnt started\");\n        _;\n    }\n\n    /**\n     * @notice owner creates a new game\n     * @param _tokenAddr - the address of the 1155 to give after completing this game\n     * @param _validUntil - the deadline to play this game\n     * @param _rules - the set of rules that the game has to follow\n     * @param cid - the pdf stored in ipfs\n     */\n    function openGame(address _tokenAddr, uint256 _validUntil, uint256[] calldata _rules, string calldata cid) external {\n        require(block.timestamp + MIN_TIME < _validUntil, \"SmartBet : End time is too soon\");\n        LibSmartBet.Game memory newGame = LibSmartBet.Game({\n            tokenAddr : _tokenAddr,\n            validUntil : _validUntil,\n            rules : _rules,\n            cid : cid\n        });\n        LibSmartBet.SmartBetStorage storage ds = LibSmartBet.smartBetStorage();\n        ds.gameCount ++;\n        ds.gameBook[ds.gameCount] = newGame;\n        emit GameOpened(ds.gameCount,newGame);\n    }\n\n    /**\n     * @notice creates a session for the a given game\n     * @param gameId - the index of the game to open a session for\n     * @param combinationHash - the combination hash of the first player\n     */\n    function openSession(uint256 gameId, bytes32 combinationHash) external {\n        LibSmartBet.SmartBetStorage storage ds = LibSmartBet.smartBetStorage();\n        ds.hasPlayedGame[gameId][msg.sender] = true;\n        address[] memory players;        \n        bytes32[] memory combinationHashes;\n        ds.sessionCount ++;\n        ds.sessionBook[ds.sessionCount] = LibSmartBet.Session({\n            players : players,\n            combinationHashes : combinationHashes,\n            turnOf : 0,\n            canPlay : false,\n            gameId : gameId,\n            finalStep : false,\n            isActive : true,\n            winner : address(0),\n            moveCount : 0\n        });\n        ds.sessionBook[ds.sessionCount].players.push(msg.sender);\n        ds.sessionBook[ds.sessionCount].combinationHashes.push(combinationHash);\n        emit SessionOpened(ds.sessionCount,ds.sessionBook[ds.sessionCount],msg.sender);\n    }   \n    /**\n     * @notice joins a session that is already existing and pending\n     * @param sessionId - the index of the session\n     * @param combinationHash - the combination hash of the player who joins this session\n     */\n    //TODO : check if the user is already in the session\n    function joinSession(uint256 sessionId, bytes32 combinationHash) external {\n        LibSmartBet.SmartBetStorage storage ds = LibSmartBet.smartBetStorage();\n        ds.sessionBook[sessionId].players.push(msg.sender);\n        ds.sessionBook[ds.sessionCount].combinationHashes.push(combinationHash);\n        ds.hasPlayedGame[ds.sessionBook[sessionId].gameId][msg.sender] = true;\n        ds.sessionBook[sessionId].canPlay = true;\n        //TODO RANDOM NUMBER to choose who starts\n        emit SessionJoined(sessionId, ds.sessionBook[sessionId], msg.sender);\n    }\n\n    /**\n     * @notice submits a move for the ongoing session\n     *         only if is the turn of the caller\n     * @param _move - the data of the move being submitted\n     * @param sessionId - the index of the session\n     */\n    function submitMove(LibSmartBet.Move memory _move, uint256 sessionId) external canMakeMove(sessionId) {\n        LibSmartBet.SmartBetStorage storage ds = LibSmartBet.smartBetStorage();\n        IGameEngine gameEngine = IGameEngine(ds.gameEngine);\n        require(gameEngine.checkIsValidMove(ds.sessionCurrMove[sessionId],_move),\"SmartBet : Move not valid\");\n        ds.sessionBook[sessionId].turnOf = ~ds.sessionBook[sessionId].turnOf & 0x1;\n        ds.sessionBook[sessionId].moveCount++;\n        bool isFinalMove = gameEngine.checkIsFinalMove(_move);\n        if(isFinalMove) {\n            ds.sessionBook[sessionId].finalStep = true;\n            ds.sessionBook[sessionId].canPlay = false;\n        }else {\n            ds.sessionCurrMove[sessionId] = _move;\n        }\n        ds.sessionCurrMove[sessionId].player = msg.sender;\n\n        emit MoveSubmitted(sessionId, ds.sessionCurrMove[sessionId], msg.sender, isFinalMove);\n    }\n\n    /**\n     * @dev submits a combination to be verified with the initial hashed combination\n     * @param sessionId - the index of the session\n     * @param key - the key the user used to submit when joined the game\n     * @param combination - the combination submitted when joined the game\n     */\n    function submitCombitation(uint256 sessionId, string memory key, bytes memory combination) external {\n        LibSmartBet.SmartBetStorage storage ds = LibSmartBet.smartBetStorage();\n        require(ds.sessionBook[sessionId].finalStep,\"SmartBet : havent reached the final step\");\n        bytes32 combinationHash = keccak256(abi.encodePacked(key,combination));\n        // TODO : improve using mapping\n        uint256 index;\n        for(uint256 i;i<ds.sessionBook[sessionId].players.length;i++){\n            if(ds.sessionBook[sessionId].players[i] == msg.sender){\n                index = i;\n            }\n        }\n        require(ds.sessionBook[sessionId].combinationHashes[index] == combinationHash, \"SmartBet : Combination and key dont match\");\n        ds.combinationBook[sessionId].push(LibSmartBet.Combination(msg.sender,combination));\n        emit CombinationSumitted(sessionId, msg.sender, combination);\n        // check if combinations are met \n        if(ds.sessionBook[sessionId].players.length == ds.combinationBook[sessionId].length){\n            _endSession(sessionId, ds.combinationBook[sessionId], ds.sessionCurrMove[sessionId].player,ds.sessionCurrMove[sessionId]);\n        }\n    }\n\n    /**\n     * @dev Finalizes session after all combinations have been submitted\n     * @param sessionId - the index of the session\n     * @param combinations - the list of combinations of this game\n     * @param endCaller - the user who claims the previous move/state ends the game\n     * @param lastMove - the previous/last move/state\n     */\n    function _endSession(uint256 sessionId,LibSmartBet.Combination[] memory combinations, address endCaller, LibSmartBet.Move memory lastMove ) internal {\n        LibSmartBet.SmartBetStorage storage ds = LibSmartBet.smartBetStorage();\n        ds.sessionBook[sessionId].isActive = false;\n        address winner = IGameEngine(ds.gameEngine).getWinner(combinations,lastMove,endCaller);\n        ds.sessionBook[sessionId].winner = winner;\n        IMockERC1155(ds.gameBook[ds.sessionBook[sessionId].gameId].tokenAddr).mint(winner,0,1,\"0x0\");\n        emit SessionEnded(sessionId, winner);\n    }\n\n    /**\n     * @dev Owner can set the game engine Addr\n     * @param gameEngineAddr - \n     */\n    function setGameEngine(address gameEngineAddr) external {\n        _onlyOwner();\n        LibSmartBet.smartBetStorage().gameEngine = gameEngineAddr;\n    }\n    function getGameEngine() external view returns (address) {\n        return LibSmartBet.smartBetStorage().gameEngine;\n    }\n    function getGameInfo (uint256 gameId) public view returns (LibSmartBet.Game memory){\n        return LibSmartBet.smartBetStorage().gameBook[gameId];\n    }\n\n    //delete function\n    function compare(bytes32 _inputHash, string memory key, uint256[] calldata combination) external pure returns (bool){\n        bytes32 hash = keccak256(abi.encodePacked(key,combination));\n        return(hash == _inputHash);\n    }\n    function getSessionInfo(uint256 sessionId) public view returns(LibSmartBet.Session memory session, LibSmartBet.Combination[] memory combinations, LibSmartBet.Move memory currMove){\n        LibSmartBet.SmartBetStorage storage ds = LibSmartBet.smartBetStorage();\n        session = ds.sessionBook[sessionId];\n        combinations = ds.combinationBook[sessionId];\n        currMove = ds.sessionCurrMove[sessionId];\n    }\n    function getAllSessionsInfo() external view returns (LibSmartBet.Session[] memory sessions){\n        LibSmartBet.SmartBetStorage storage ds = LibSmartBet.smartBetStorage();\n        sessions = new LibSmartBet.Session[](ds.sessionCount);\n        for(uint256 i=1; i<=ds.sessionCount; i++){\n            (sessions[i-1],,) = getSessionInfo(i);\n        }\n    }\n    function getAllGamesInfo() external view returns (LibSmartBet.Game[] memory games){\n        LibSmartBet.SmartBetStorage storage ds = LibSmartBet.smartBetStorage();\n        games = new LibSmartBet.Game[](ds.gameCount);\n        for(uint256 i=1; i<=ds.gameCount; i++){\n            games[i-1] = getGameInfo(i);\n        }\n    }\n}"
    },
    "contracts/GameEngine.sol": {
      "content": "pragma solidity ^0.8.17;\n\nimport {IGameEngine} from \"./interfaces/IGameEngine.sol\";\nimport {LibSmartBet} from \"./libraries/LibSmartBet.sol\";\ncontract GameEngine is IGameEngine {\n    function checkIsFinalMove(LibSmartBet.Move memory move) external view returns (bool) {\n        return (move.moveType == LibSmartBet.Moves.FinalMove);\n    }\n    function getWinner(LibSmartBet.Combination[] memory combinations, LibSmartBet.Move memory move, address endCaller) external pure returns (address){\n        (uint256[] memory combination1) = abi.decode(combinations[0].combinationData,(uint256[]));\n        (uint256[] memory combination2) = abi.decode(combinations[1].combinationData,(uint256[]));\n        address player1 = combinations[0].player;\n        address player2 = combinations[1].player;\n        (uint256 qty, uint256 num) = abi.decode(move.moveData,(uint256,uint256));\n        uint256 _qty;\n        for(uint256 i=0;i<combination1.length;i++){\n            if(combination1[i]==num){\n                _qty++;\n            }\n        }\n        for(uint256 i=0;i<combination2.length;i++){\n            if(combination2[i]==num){\n                _qty++;\n            }\n        }\n        if(_qty >= qty ){\n            if(player1 == endCaller){\n                return player2;\n            }else{\n                return player1;\n            }\n        }\n        return endCaller;\n    }\n    /**\n     * @dev this is a customizable function\n     * @param previousMove - last move done\n     * @param newMove - incoming move\n     * @notice checks if a move is valid based on the previous move\n     *         in this example, qty should be less than 6 and number should be from 1-6\n     *         also the incoming move has to be greater than the previous one\n     *         the first move starts with at least qty 2 or num 2\n     */\n    function checkIsValidMove(LibSmartBet.Move memory previousMove, LibSmartBet.Move memory newMove) external pure returns (bool){\n        (uint256 qty, uint256 num) = abi.decode(newMove.moveData,(uint256,uint256));\n        if(newMove.moveType == LibSmartBet.Moves.FirstMove){\n            return (qty >= 2 && num >= 2 && qty <= 12 && num <= 6);\n        }\n        (uint256 _qty, uint256 _num) = abi.decode(previousMove.moveData,(uint256,uint256));\n        return(qty + num > _qty + _num && qty < 12 && num < 6);\n        // return true;\n    }\n \n}\n\ncontract GameEngineTest {\n    struct Move{\n        bytes moveData;\n        uint256 moveType;\n        address player;\n    }\n\n    function checkIsValidMove(Move memory _move) external view returns (uint256, uint256) {\n        (uint256 qty,uint256 number) = abi.decode(_move.moveData,(uint256,uint256));\n        return (qty, number);\n    }\n    function getList(bytes memory combination) external view returns (uint256[] memory list) {\n        (list) = abi.decode(combination,(uint256[]));\n    }\n    function getWinner(LibSmartBet.Combination[] memory combinations, LibSmartBet.Move memory move, address endCaller) external pure returns (address){\n        (uint256[] memory combination1) = abi.decode(combinations[0].combinationData,(uint256[]));\n        (uint256[] memory combination2) = abi.decode(combinations[1].combinationData,(uint256[]));\n        address player1 = combinations[0].player;\n        address player2 = combinations[1].player;\n        (uint256 qty, uint256 num) = abi.decode(move.moveData,(uint256,uint256));\n        uint256 _qty;\n        for(uint256 i=0;i<combination1.length;i++){\n            if(combination1[i]==num){\n                _qty++;\n            }\n        }\n        for(uint256 i=0;i<combination2.length;i++){\n            if(combination2[i]==num){\n                _qty++;\n            }\n        }\n        if(_qty >= qty ){\n            if(player1 == endCaller){\n                return player2;\n            }else{\n                return player1;\n            }\n        }\n        return endCaller;\n    }\n}"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Adapted from the Diamond 3 reference implementation by Nick Mudge:\n// https://github.com/mudgen/diamond-3-hardhat\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/interfaces/IGameEngine.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport {LibSmartBet} from \"../libraries/LibSmartBet.sol\";\ninterface IGameEngine {\n    function checkIsValidMove(LibSmartBet.Move memory,LibSmartBet.Move memory) external view returns (bool);\n    function checkIsFinalMove(LibSmartBet.Move memory) external view returns (bool);\n    function getWinner(LibSmartBet.Combination[] memory, LibSmartBet.Move memory, address) external view returns (address);\n}"
    },
    "contracts/interfaces/IMockERC1155.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n///@notice This contract is for mock for WETH token.\npragma solidity ^0.8.17;\n\ninterface IMockERC1155 {\n    function mint(address, uint256, uint256, bytes memory) external;\n    function mintBatch(address, uint256[] memory, uint256[] memory) external;\n}\n"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Adapted from the Diamond 3 reference implementation by Nick Mudge:\n// https://github.com/mudgen/diamond-3-hardhat\n\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(\n    address _initializationContractAddress,\n    bytes _calldata\n);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(\n            msg.sender == diamondStorage().contractOwner,\n            \"LibDiamond: Must be contract owner\"\n        );\n    }\n\n    event DiamondCut(\n        IDiamondCut.FacetCut[] _diamondCut,\n        address _init,\n        bytes _calldata\n    );\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (\n            uint256 facetIndex;\n            facetIndex < _diamondCut.length;\n            facetIndex++\n        ) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(\n            _functionSelectors.length > 0,\n            \"LibDiamondCut: No selectors in facet to cut\"\n        );\n        DiamondStorage storage ds = diamondStorage();\n        require(\n            _facetAddress != address(0),\n            \"LibDiamondCut: Add facet can't be address(0)\"\n        );\n        uint96 selectorPosition = uint96(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            require(\n                oldFacetAddress == address(0),\n                \"LibDiamondCut: Can't add function that already exists\"\n            );\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(\n            _functionSelectors.length > 0,\n            \"LibDiamondCut: No selectors in facet to cut\"\n        );\n        DiamondStorage storage ds = diamondStorage();\n        require(\n            _facetAddress != address(0),\n            \"LibDiamondCut: Add facet can't be address(0)\"\n        );\n        uint96 selectorPosition = uint96(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            require(\n                oldFacetAddress != _facetAddress,\n                \"LibDiamondCut: Can't replace function with same function\"\n            );\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(\n            _functionSelectors.length > 0,\n            \"LibDiamondCut: No selectors in facet to cut\"\n        );\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(\n            _facetAddress == address(0),\n            \"LibDiamondCut: Remove facet address must be address(0)\"\n        );\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress)\n        internal\n    {\n        enforceHasContractCode(\n            _facetAddress,\n            \"LibDiamondCut: New facet has no code\"\n        );\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds\n            .facetAddresses\n            .length;\n        ds.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(\n        DiamondStorage storage ds,\n        bytes4 _selector,\n        uint96 _selectorPosition,\n        address _facetAddress\n    ) internal {\n        ds\n            .selectorToFacetAndPosition[_selector]\n            .functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\n            _selector\n        );\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(\n        DiamondStorage storage ds,\n        address _facetAddress,\n        bytes4 _selector\n    ) internal {\n        require(\n            _facetAddress != address(0),\n            \"LibDiamondCut: Can't remove function that doesn't exist\"\n        );\n        // an immutable function is a function defined directly in a diamond\n        require(\n            _facetAddress != address(this),\n            \"LibDiamondCut: Can't remove immutable function\"\n        );\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds\n            .selectorToFacetAndPosition[_selector]\n            .functionSelectorPosition;\n        uint256 lastSelectorPosition = ds\n            .facetFunctionSelectors[_facetAddress]\n            .functionSelectors\n            .length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds\n                .facetFunctionSelectors[_facetAddress]\n                .functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\n                    selectorPosition\n                ] = lastSelector;\n            ds\n                .selectorToFacetAndPosition[lastSelector]\n                .functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[\n                    lastFacetAddressPosition\n                ];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds\n                    .facetFunctionSelectors[lastFacetAddress]\n                    .facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata)\n        internal\n    {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(\n            _init,\n            \"LibDiamondCut: _init address has no code\"\n        );\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(\n        address _contract,\n        string memory _errorMessage\n    ) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/libraries/LibSmartBet.sol": {
      "content": "pragma solidity ^0.8.17;\n\nlibrary LibSmartBet {\n\n    // customisable\n    enum Moves{\n        PlayMove, //  a normal move\n        FinalMove, // a move that calls the checker\n        FirstMove //  a first move ( skips some checkers )\n    }\n    bytes32 constant STORAGE_POSITION = keccak256(\"g7dao.eth.storage.SmartBet\");\n    \n\n    struct Game {\n        address tokenAddr; // address of the 1155 to mint to the winner\n        uint256 validUntil; // deadline for members of the DAO to play the game\n        uint256[] rules; // list of rules the game is based on\n        string cid; // CID of the ipfs proposal we want to share\n    }\n    struct Combination {\n        address player; // the playet to whom this combination belongs\n        bytes combinationData;  // combination data is customizable i.e. (uint256[])\n    }\n    struct Session {\n        address[] players; // list of players in the session\n        bytes32[] combinationHashes; // list of inital combinations\n        uint256 turnOf; //index of the player who plays now\n        bool canPlay; //whether the game can be started\n        uint256 gameId; // id of the game this is playing for \n        bool finalStep; // whether this is the final step , will require you to submit combinations \n        bool isActive; // will be inactive after the session was closed\n        address winner; // the winner of the closed session\n        uint256 moveCount;\n    }\n    struct Move {\n        bytes moveData; // move data is customizable i.e. (uint256, uint256)\n        Moves moveType; // type of the move\n        address player; // player that executes a move\n    }\n    struct SmartBetStorage {\n        address movesRegistry; // contract containing a list of declared / available moves\n        address gameEngine; // contract containing the logic to choose the winner of the game\n        uint256 gameCount; // keeps track of the number of games\n        uint256 sessionCount; // keeps track of the number of sessions\n\n        //      gameId             addr      yes/no\n        mapping(uint256 => mapping(address => bool)) hasPlayedGame; // tracks weather a player has played the game\n\n        //      sessionId   CombinationData\n        mapping(uint256 => Combination[]) combinationBook; // combinations of the players of each session\n\n        //      gameId     gameData\n        mapping(uint256 => Game) gameBook; // list of games in the contract\n\n        //      sessionId    SessionData \n        mapping(uint256  => Session) sessionBook; // list of sessions in the contract\n\n        //      sessionId  Move\n        mapping(uint256 => Move) sessionCurrMove; // tracks the current move of a session\n    }\n\n    function smartBetStorage()\n        internal\n        pure\n        returns (SmartBetStorage storage ds)\n    {\n        bytes32 position = STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}