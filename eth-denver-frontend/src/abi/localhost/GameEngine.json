{
  "address": "0x2279B7A0a67DB372996a5FaB50D91eAA73d2eBe6",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "moveData",
              "type": "bytes"
            },
            {
              "internalType": "enum LibSmartBet.Moves",
              "name": "moveType",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "player",
              "type": "address"
            }
          ],
          "internalType": "struct LibSmartBet.Move",
          "name": "move",
          "type": "tuple"
        }
      ],
      "name": "checkIsFinalMove",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "moveData",
              "type": "bytes"
            },
            {
              "internalType": "enum LibSmartBet.Moves",
              "name": "moveType",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "player",
              "type": "address"
            }
          ],
          "internalType": "struct LibSmartBet.Move",
          "name": "previousMove",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "moveData",
              "type": "bytes"
            },
            {
              "internalType": "enum LibSmartBet.Moves",
              "name": "moveType",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "player",
              "type": "address"
            }
          ],
          "internalType": "struct LibSmartBet.Move",
          "name": "newMove",
          "type": "tuple"
        }
      ],
      "name": "checkIsValidMove",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "player",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "combinationData",
              "type": "bytes"
            }
          ],
          "internalType": "struct LibSmartBet.Combination[]",
          "name": "combinations",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "moveData",
              "type": "bytes"
            },
            {
              "internalType": "enum LibSmartBet.Moves",
              "name": "moveType",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "player",
              "type": "address"
            }
          ],
          "internalType": "struct LibSmartBet.Move",
          "name": "move",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "endCaller",
          "type": "address"
        }
      ],
      "name": "getWinner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x118b18bc6b7bb0a28847b39de3bf2c4fe8c6f94c3596aad497b75cca70ebcb18",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x2279B7A0a67DB372996a5FaB50D91eAA73d2eBe6",
    "transactionIndex": 0,
    "gasUsed": "504771",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x356211ee3c270a1aa79c3694620775caa32f63bfd3e3ff68093682809f2ad258",
    "transactionHash": "0x118b18bc6b7bb0a28847b39de3bf2c4fe8c6f94c3596aad497b75cca70ebcb18",
    "logs": [],
    "blockNumber": 9,
    "cumulativeGasUsed": "504771",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "57ec3976d11a2b6e33402339eb22cc99",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"moveData\",\"type\":\"bytes\"},{\"internalType\":\"enum LibSmartBet.Moves\",\"name\":\"moveType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"internalType\":\"struct LibSmartBet.Move\",\"name\":\"move\",\"type\":\"tuple\"}],\"name\":\"checkIsFinalMove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"moveData\",\"type\":\"bytes\"},{\"internalType\":\"enum LibSmartBet.Moves\",\"name\":\"moveType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"internalType\":\"struct LibSmartBet.Move\",\"name\":\"previousMove\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"moveData\",\"type\":\"bytes\"},{\"internalType\":\"enum LibSmartBet.Moves\",\"name\":\"moveType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"internalType\":\"struct LibSmartBet.Move\",\"name\":\"newMove\",\"type\":\"tuple\"}],\"name\":\"checkIsValidMove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"combinationData\",\"type\":\"bytes\"}],\"internalType\":\"struct LibSmartBet.Combination[]\",\"name\":\"combinations\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"moveData\",\"type\":\"bytes\"},{\"internalType\":\"enum LibSmartBet.Moves\",\"name\":\"moveType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"internalType\":\"struct LibSmartBet.Move\",\"name\":\"move\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"endCaller\",\"type\":\"address\"}],\"name\":\"getWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"checkIsValidMove((bytes,uint8,address),(bytes,uint8,address))\":{\"details\":\"this is a customizable function\",\"params\":{\"newMove\":\"- incoming move\",\"previousMove\":\"- last move done\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"checkIsValidMove((bytes,uint8,address),(bytes,uint8,address))\":{\"notice\":\"checks if a move is valid based on the previous move         in this example, qty should be less than 6 and number should be from 1-6         also the incoming move has to be greater than the previous one         the first move starts with at least qty 2 or num 2\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/GameEngine.sol\":\"GameEngine\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/GameEngine.sol\":{\"content\":\"pragma solidity ^0.8.17;\\n\\nimport {IGameEngine} from \\\"./interfaces/IGameEngine.sol\\\";\\nimport {LibSmartBet} from \\\"./libraries/LibSmartBet.sol\\\";\\ncontract GameEngine is IGameEngine {\\n    function checkIsFinalMove(LibSmartBet.Move memory move) external view returns (bool) {\\n        return (move.moveType == LibSmartBet.Moves.FinalMove);\\n    }\\n    function getWinner(LibSmartBet.Combination[] memory combinations, LibSmartBet.Move memory move, address endCaller) external pure returns (address){\\n        (uint256[] memory combination1) = abi.decode(combinations[0].combinationData,(uint256[]));\\n        (uint256[] memory combination2) = abi.decode(combinations[1].combinationData,(uint256[]));\\n        address player1 = combinations[0].player;\\n        address player2 = combinations[1].player;\\n        (uint256 qty, uint256 num) = abi.decode(move.moveData,(uint256,uint256));\\n        uint256 _qty;\\n        for(uint256 i=0;i<combination1.length;i++){\\n            if(combination1[i]==num){\\n                _qty++;\\n            }\\n        }\\n        for(uint256 i=0;i<combination2.length;i++){\\n            if(combination2[i]==num){\\n                _qty++;\\n            }\\n        }\\n        if(_qty >= qty ){\\n            if(player1 == endCaller){\\n                return player2;\\n            }else{\\n                return player1;\\n            }\\n        }\\n        return endCaller;\\n    }\\n    /**\\n     * @dev this is a customizable function\\n     * @param previousMove - last move done\\n     * @param newMove - incoming move\\n     * @notice checks if a move is valid based on the previous move\\n     *         in this example, qty should be less than 6 and number should be from 1-6\\n     *         also the incoming move has to be greater than the previous one\\n     *         the first move starts with at least qty 2 or num 2\\n     */\\n    function checkIsValidMove(LibSmartBet.Move memory previousMove, LibSmartBet.Move memory newMove) external pure returns (bool){\\n        (uint256 qty, uint256 num) = abi.decode(newMove.moveData,(uint256,uint256));\\n        if(newMove.moveType == LibSmartBet.Moves.FirstMove){\\n            return (qty >= 2 && num >= 2 && qty <= 12 && num <= 6);\\n        }\\n        (uint256 _qty, uint256 _num) = abi.decode(previousMove.moveData,(uint256,uint256));\\n        return(qty + num > _qty + _num && qty < 12 && num < 6);\\n        // return true;\\n    }\\n \\n}\\n\\ncontract GameEngineTest {\\n    struct Move{\\n        bytes moveData;\\n        uint256 moveType;\\n        address player;\\n    }\\n\\n    function checkIsValidMove(Move memory _move) external view returns (uint256, uint256) {\\n        (uint256 qty,uint256 number) = abi.decode(_move.moveData,(uint256,uint256));\\n        return (qty, number);\\n    }\\n    function getList(bytes memory combination) external view returns (uint256[] memory list) {\\n        (list) = abi.decode(combination,(uint256[]));\\n    }\\n    function getWinner(LibSmartBet.Combination[] memory combinations, LibSmartBet.Move memory move, address endCaller) external pure returns (address){\\n        (uint256[] memory combination1) = abi.decode(combinations[0].combinationData,(uint256[]));\\n        (uint256[] memory combination2) = abi.decode(combinations[1].combinationData,(uint256[]));\\n        address player1 = combinations[0].player;\\n        address player2 = combinations[1].player;\\n        (uint256 qty, uint256 num) = abi.decode(move.moveData,(uint256,uint256));\\n        uint256 _qty;\\n        for(uint256 i=0;i<combination1.length;i++){\\n            if(combination1[i]==num){\\n                _qty++;\\n            }\\n        }\\n        for(uint256 i=0;i<combination2.length;i++){\\n            if(combination2[i]==num){\\n                _qty++;\\n            }\\n        }\\n        if(_qty >= qty ){\\n            if(player1 == endCaller){\\n                return player2;\\n            }else{\\n                return player1;\\n            }\\n        }\\n        return endCaller;\\n    }\\n}\",\"keccak256\":\"0x9fbe1f3ea4e6bddaba84d7d56a93d7c7ff57b94cc8aef9ebead404ac54a3082e\"},\"contracts/interfaces/IGameEngine.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\nimport {LibSmartBet} from \\\"../libraries/LibSmartBet.sol\\\";\\ninterface IGameEngine {\\n    function checkIsValidMove(LibSmartBet.Move memory,LibSmartBet.Move memory) external view returns (bool);\\n    function checkIsFinalMove(LibSmartBet.Move memory) external view returns (bool);\\n    function getWinner(LibSmartBet.Combination[] memory, LibSmartBet.Move memory, address) external view returns (address);\\n}\",\"keccak256\":\"0x97fabceb7057145b38643b654c2e2da1609f647cab57a8803e0c5dc0dee63bd7\"},\"contracts/libraries/LibSmartBet.sol\":{\"content\":\"pragma solidity ^0.8.17;\\n\\nlibrary LibSmartBet {\\n\\n    // customisable\\n    enum Moves{\\n        PlayMove, //  a normal move\\n        FinalMove, // a move that calls the checker\\n        FirstMove //  a first move ( skips some checkers )\\n    }\\n    bytes32 constant STORAGE_POSITION = keccak256(\\\"g7dao.eth.storage.SmartBet\\\");\\n    \\n\\n    struct Game {\\n        address tokenAddr; // address of the 1155 to mint to the winner\\n        uint256 validUntil; // deadline for members of the DAO to play the game\\n        uint256[] rules; // list of rules the game is based on\\n        string cid; // CID of the ipfs proposal we want to share\\n    }\\n    struct Combination {\\n        address player; // the playet to whom this combination belongs\\n        bytes combinationData;  // combination data is customizable i.e. (uint256[])\\n    }\\n    struct Session {\\n        address[] players; // list of players in the session\\n        bytes32[] combinationHashes; // list of inital combinations\\n        uint256 turnOf; //index of the player who plays now\\n        bool canPlay; //whether the game can be started\\n        uint256 gameId; // id of the game this is playing for \\n        bool finalStep; // whether this is the final step , will require you to submit combinations \\n        bool isActive; // will be inactive after the session was closed\\n        address winner; // the winner of the closed session\\n        uint256 moveCount;\\n    }\\n    struct Move {\\n        bytes moveData; // move data is customizable i.e. (uint256, uint256)\\n        Moves moveType; // type of the move\\n        address player; // player that executes a move\\n    }\\n    struct SmartBetStorage {\\n        address movesRegistry; // contract containing a list of declared / available moves\\n        address gameEngine; // contract containing the logic to choose the winner of the game\\n        uint256 gameCount; // keeps track of the number of games\\n        uint256 sessionCount; // keeps track of the number of sessions\\n\\n        //      gameId             addr      yes/no\\n        mapping(uint256 => mapping(address => bool)) hasPlayedGame; // tracks weather a player has played the game\\n\\n        //      sessionId   CombinationData\\n        mapping(uint256 => Combination[]) combinationBook; // combinations of the players of each session\\n\\n        //      gameId     gameData\\n        mapping(uint256 => Game) gameBook; // list of games in the contract\\n\\n        //      sessionId    SessionData \\n        mapping(uint256  => Session) sessionBook; // list of sessions in the contract\\n\\n        //      sessionId  Move\\n        mapping(uint256 => Move) sessionCurrMove; // tracks the current move of a session\\n    }\\n\\n    function smartBetStorage()\\n        internal\\n        pure\\n        returns (SmartBetStorage storage ds)\\n    {\\n        bytes32 position = STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\",\"keccak256\":\"0x069094218c008fb40e2c0af6c1da9dc627c705f6ee0c588073c845b2eb3a49d3\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061082c806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80634c58bffd14610046578063b46ffe571461006e578063c4a2b0c614610081575b600080fd5b6100596100543660046104e2565b6100ac565b60405190151581526020015b60405180910390f35b61005961007c36600461051f565b6100cd565b61009461008f3660046105a7565b61019b565b6040516001600160a01b039091168152602001610065565b60006001826020015160028111156100c6576100c66106d3565b1492915050565b600080600083600001518060200190518101906100ea91906106e9565b9092509050600284602001516002811115610107576101076106d3565b03610141576002821015801561011e575060028110155b801561012b5750600c8211155b8015610138575060068111155b92505050610195565b600080866000015180602001905181019061015c91906106e9565b909250905061016b8183610723565b6101758486610723565b1180156101825750600c84105b801561018e5750600683105b9450505050505b92915050565b600080846000815181106101b1576101b1610736565b6020026020010151602001518060200190518101906101d0919061074c565b90506000856001815181106101e7576101e7610736565b602002602001015160200151806020019051810190610206919061074c565b905060008660008151811061021d5761021d610736565b602002602001015160000151905060008760018151811061024057610240610736565b6020026020010151600001519050600080886000015180602001905181019061026991906106e9565b90925090506000805b87518110156102bb578288828151811061028e5761028e610736565b6020026020010151036102a957816102a5816107dd565b9250505b806102b3816107dd565b915050610272565b5060005b865181101561030857828782815181106102db576102db610736565b6020026020010151036102f657816102f2816107dd565b9250505b80610300816107dd565b9150506102bf565b5082811061034757886001600160a01b0316856001600160a01b0316036103385783975050505050505050610352565b84975050505050505050610352565b889750505050505050505b9392505050565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff8111828210171561039257610392610359565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156103c1576103c1610359565b604052919050565b600082601f8301126103da57600080fd5b813567ffffffffffffffff8111156103f4576103f4610359565b610407601f8201601f1916602001610398565b81815284602083860101111561041c57600080fd5b816020850160208301376000918101602001919091529392505050565b80356001600160a01b038116811461045057600080fd5b919050565b60006060828403121561046757600080fd5b6040516060810167ffffffffffffffff828210818311171561048b5761048b610359565b8160405282935084359150808211156104a357600080fd5b506104b0858286016103c9565b8252506020830135600381106104c557600080fd5b60208201526104d660408401610439565b60408201525092915050565b6000602082840312156104f457600080fd5b813567ffffffffffffffff81111561050b57600080fd5b61051784828501610455565b949350505050565b6000806040838503121561053257600080fd5b823567ffffffffffffffff8082111561054a57600080fd5b61055686838701610455565b9350602085013591508082111561056c57600080fd5b5061057985828601610455565b9150509250929050565b600067ffffffffffffffff82111561059d5761059d610359565b5060051b60200190565b6000806000606084860312156105bc57600080fd5b833567ffffffffffffffff808211156105d457600080fd5b818601915086601f8301126105e857600080fd5b813560206105fd6105f883610583565b610398565b82815260059290921b8401810191818101908a84111561061c57600080fd5b8286015b848110156106975780358681111561063757600080fd5b87016040818e03601f1901121561064e5760008081fd5b61065661036f565b610661868301610439565b81526040820135888111156106765760008081fd5b6106848f88838601016103c9565b8288015250845250918301918301610620565b50975050870135925050808211156106ae57600080fd5b506106bb86828701610455565b9250506106ca60408501610439565b90509250925092565b634e487b7160e01b600052602160045260246000fd5b600080604083850312156106fc57600080fd5b505080516020909101519092909150565b634e487b7160e01b600052601160045260246000fd5b808201808211156101955761019561070d565b634e487b7160e01b600052603260045260246000fd5b6000602080838503121561075f57600080fd5b825167ffffffffffffffff81111561077657600080fd5b8301601f8101851361078757600080fd5b80516107956105f882610583565b81815260059190911b820183019083810190878311156107b457600080fd5b928401925b828410156107d2578351825292840192908401906107b9565b979650505050505050565b6000600182016107ef576107ef61070d565b506001019056fea264697066735822122038ac6bb31c2429361303524a1b409a7c2008ce14ed6de86165696d13546b785264736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c80634c58bffd14610046578063b46ffe571461006e578063c4a2b0c614610081575b600080fd5b6100596100543660046104e2565b6100ac565b60405190151581526020015b60405180910390f35b61005961007c36600461051f565b6100cd565b61009461008f3660046105a7565b61019b565b6040516001600160a01b039091168152602001610065565b60006001826020015160028111156100c6576100c66106d3565b1492915050565b600080600083600001518060200190518101906100ea91906106e9565b9092509050600284602001516002811115610107576101076106d3565b03610141576002821015801561011e575060028110155b801561012b5750600c8211155b8015610138575060068111155b92505050610195565b600080866000015180602001905181019061015c91906106e9565b909250905061016b8183610723565b6101758486610723565b1180156101825750600c84105b801561018e5750600683105b9450505050505b92915050565b600080846000815181106101b1576101b1610736565b6020026020010151602001518060200190518101906101d0919061074c565b90506000856001815181106101e7576101e7610736565b602002602001015160200151806020019051810190610206919061074c565b905060008660008151811061021d5761021d610736565b602002602001015160000151905060008760018151811061024057610240610736565b6020026020010151600001519050600080886000015180602001905181019061026991906106e9565b90925090506000805b87518110156102bb578288828151811061028e5761028e610736565b6020026020010151036102a957816102a5816107dd565b9250505b806102b3816107dd565b915050610272565b5060005b865181101561030857828782815181106102db576102db610736565b6020026020010151036102f657816102f2816107dd565b9250505b80610300816107dd565b9150506102bf565b5082811061034757886001600160a01b0316856001600160a01b0316036103385783975050505050505050610352565b84975050505050505050610352565b889750505050505050505b9392505050565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff8111828210171561039257610392610359565b60405290565b604051601f8201601f1916810167ffffffffffffffff811182821017156103c1576103c1610359565b604052919050565b600082601f8301126103da57600080fd5b813567ffffffffffffffff8111156103f4576103f4610359565b610407601f8201601f1916602001610398565b81815284602083860101111561041c57600080fd5b816020850160208301376000918101602001919091529392505050565b80356001600160a01b038116811461045057600080fd5b919050565b60006060828403121561046757600080fd5b6040516060810167ffffffffffffffff828210818311171561048b5761048b610359565b8160405282935084359150808211156104a357600080fd5b506104b0858286016103c9565b8252506020830135600381106104c557600080fd5b60208201526104d660408401610439565b60408201525092915050565b6000602082840312156104f457600080fd5b813567ffffffffffffffff81111561050b57600080fd5b61051784828501610455565b949350505050565b6000806040838503121561053257600080fd5b823567ffffffffffffffff8082111561054a57600080fd5b61055686838701610455565b9350602085013591508082111561056c57600080fd5b5061057985828601610455565b9150509250929050565b600067ffffffffffffffff82111561059d5761059d610359565b5060051b60200190565b6000806000606084860312156105bc57600080fd5b833567ffffffffffffffff808211156105d457600080fd5b818601915086601f8301126105e857600080fd5b813560206105fd6105f883610583565b610398565b82815260059290921b8401810191818101908a84111561061c57600080fd5b8286015b848110156106975780358681111561063757600080fd5b87016040818e03601f1901121561064e5760008081fd5b61065661036f565b610661868301610439565b81526040820135888111156106765760008081fd5b6106848f88838601016103c9565b8288015250845250918301918301610620565b50975050870135925050808211156106ae57600080fd5b506106bb86828701610455565b9250506106ca60408501610439565b90509250925092565b634e487b7160e01b600052602160045260246000fd5b600080604083850312156106fc57600080fd5b505080516020909101519092909150565b634e487b7160e01b600052601160045260246000fd5b808201808211156101955761019561070d565b634e487b7160e01b600052603260045260246000fd5b6000602080838503121561075f57600080fd5b825167ffffffffffffffff81111561077657600080fd5b8301601f8101851361078757600080fd5b80516107956105f882610583565b81815260059190911b820183019083810190878311156107b457600080fd5b928401925b828410156107d2578351825292840192908401906107b9565b979650505050505050565b6000600182016107ef576107ef61070d565b506001019056fea264697066735822122038ac6bb31c2429361303524a1b409a7c2008ce14ed6de86165696d13546b785264736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "checkIsValidMove((bytes,uint8,address),(bytes,uint8,address))": {
        "details": "this is a customizable function",
        "params": {
          "newMove": "- incoming move",
          "previousMove": "- last move done"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "checkIsValidMove((bytes,uint8,address),(bytes,uint8,address))": {
        "notice": "checks if a move is valid based on the previous move         in this example, qty should be less than 6 and number should be from 1-6         also the incoming move has to be greater than the previous one         the first move starts with at least qty 2 or num 2"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}